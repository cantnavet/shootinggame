<!DOCTYPE html>
<html>
<head>
    <meta charset = "UTF-8">
    <title>射击游戏</title>
    <style>

        @font-face {
            font-family: 'Jellee';
            src: url('fonts/Jellee.ttf');
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Jellee', sans-serif; /* 可以将这个字体应用到整个页面或特定元素 */
        }
        canvas { border: 1px solid white }
        canvas {
            user-select: none;
            -webkit-user-select: none;
        }
        #restartBtn { display: none; padding: 10px 20px; }

        .bg-container {
        position: fixed;
        top: -100%;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('textures/d1b.png');
        background-size: cover;
        background-position: center top;
        z-index: -1145141919; /*(?)*/
        opacity: 1;
        transition: top 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .bg2-container {
        position: fixed;
        top: -100%;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('textures/d2b.png');
        background-size: cover;
        background-position: center top;
        z-index: -1145141920; 
        opacity: 1;
        transition: top 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .active {
        top: 0;
        opacity: 1;
        }

    </style>
</head>
<body bgcolor="333333">
    <span style="display: flex;">
        <canvas id="gameCanvas" width="600" height="800"></canvas>
        <div class="bg-container" id="bg"></div>
        <div class="bg2-container" id="bg2"></div>
        <div>
            <button id="stop" style="width: 50px; height: 50px;" onclick="stop();">| |</button>
            <button id="restartBtn" style="height: 50px;">↺</button>
        </div>
    </span>
    <div style="color: white; margin-top: 10px;">
        游戏倍速: 
        <input type="range" id="speedRange" min="1" max="1" step="0.5" value="1" 
               style="vertical-align: middle; width: 100px;">
        <span id="speedValue">1x</span>
    </div>
    
    <br>
    <!-- <button id="left" style="width: 300px; height: 100px;">←</button>
    <button id="right" style="width: 300px; height: 100px;">→</button> -->
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const bgE = document.getElementById('bg');
        const bg2E = document.getElementById('bg2');
        const ctx = canvas.getContext('2d');
        const restartBtn = document.getElementById('restartBtn');

        //伏笔，后面要考
        const damageTypes =[1.5,200,60000,20000000,6000000000,1000000000000];
        const XTypes =[1,2,3,4,5,6];
        const upgradeSpawnTime =[400,800,1200,1600,2000,99999999];
        const colors =['#ffffff','#ffffff','#ffff00','#888888','#00ffff','#000000'];
        const barrierColor1 = [];
        const barrierColor2 = [];
        const bulletSpeeds =[5,8,12,16,22,30];
        const fireLims =[5,4,3.3,2.5,2,1];
        const MaxD = 11;
        var dx = new Array();
        for (i=1;i<=MaxD;i++){
            dx[i] = new Image();
            dx[i].src = 'textures/d'+i+'.png';
        }

        const bType1 = new Image();
        bType1.src = 'textures/leather_boots.png';
        const bType2 = new Image();
        bType2.src = 'textures/iron_boots.png';
        const bType3 = new Image();
        bType3.src = 'textures/gold_boots.png';
        const bType4 = new Image();
        bType4.src = 'textures/chainmail_boots.png';
        const bType5 = new Image();
        bType5.src = 'textures/diamond_boots.png';
        const bType6 = new Image();
        bType6.src = 'textures/netherite_boots.png';

        const bTypes = [bType1,bType2,bType3,bType4,bType5,bType6];


        let bulletCache;

        let timeScale = 1;
        let bulletWeight;
        let kickbackDistance;
        let damageDe = 1;
        let enemyHealthRate;
        let gameTime;
        let deltaTime;
        let lastFrameTime = Date.now();
        const Maxbullets = [35,30,25,20,15,6];
        const minFrameTime = 1000 / 60; 
        let enemiesSizeBase = 15;
        let fallSpeedBase = 0.7;
        let player, bullets, enemies, barriers, lastFire, gameOver, stops;
        let score = 0;
        let enemySpawnTimer = 0;
        let upgradeSpawnTimer = 0;
        let enemyHealthBase = 3;
        let enemySpawnRate = 2000;
        let barrierCD = false;
        let buttonR = document.getElementById('right');
        let buttonL = document.getElementById('left');
        let interval;
        let interval2;
        let stopTime;
        let lastSec = 0;
        let mouseX = canvas.width/2;
        let scale;
        let difficultyApplyed;
        let noFireRate; //连续出现无攻速加成的次数
        let zindex1 = -1145141919;
        let zindex2 = -1145141920;
        let difficulty;

        const speedRange = document.getElementById('speedRange');
        speedRange.addEventListener('input', function() {
            timeScale = parseFloat(this.value);
            document.getElementById('speedValue').textContent = this.value + 'x';
        });

        function test(){
            player.ar=3;
            player.at=1;
        }

        // 双重背景笑传之层层搬(
        function updateBG() {
            if (zindex1<zindex2) {
                zindex1=zindex2+1;
                bgE.style.zIndex = zindex2+1;
                bgE.style.backgroundImage= "url('textures/d"+difficulty+"b.png')";
                triggerAnimation(offAnimation2);
            }else{
                zindex2=zindex1+1;
                bg2E.style.zIndex = zindex1+1;
                bg2E.style.backgroundImage= "url('textures/d"+difficulty+"b.png')";
                triggerAnimation2(offAnimation);
            }
        }

        // 设置 Canvas + bg 的CSS显示大小
        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            const logicalWidth = canvas.width; 
            const logicalHeight = canvas.height; 

            scale = Math.min((windowWidth-50) / logicalWidth, (windowHeight-50) / logicalHeight);

            canvas.style.width = `${logicalWidth * scale}px`;
            canvas.style.height = `${logicalHeight * scale}px`;
            bgE.style.width = `${logicalWidth * scale}px`;
            bgE.style.height = `${logicalHeight * scale}px`;
            bg2E.style.width = `${logicalWidth * scale}px`;
            bg2E.style.height = `${logicalHeight * scale}px`;
        }
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw(); 
        });

        function updateDeltaTime() {
            const now = Date.now();
            lastFrameTime = now;
            gameTime += deltaTime;
        }

        
        function initGame() {
            ctx.imageSmoothingEnabled = false; 
            player = {
                x: canvas.width/2,
                y: canvas.height - 30,
                speed: 5,
                bulletSpeed: 2,
                fireRate: 1000,
                damage: 1,
                bulletWidth: 4.5,
                bulletCount: 1,  // 初始弹道数量
                bulletSpread: 18, // 子弹间距
                bulletX: 1,
                health: 9999,
                maxHealth: 9999,
                bulletType: 1,
                fireLim: 5,
                ar: 1,
                at: 0
            };
            //预渲染靴子弹 (?)
            bulletCache = [{
                left: createCachedImage(bTypes[0], -2, 3, 10, 10, 30, 30),
                right: createCachedImage(bTypes[0], 8, 3, 10, 10, 30, 30) 
            },{
                left: createCachedImage(bTypes[1], -2, 3, 10, 10, 30, 30),
                right: createCachedImage(bTypes[1], 8, 3, 10, 10, 30, 30) 
            },{
                left: createCachedImage(bTypes[2], -2, 3, 10, 10, 30, 30),
                right: createCachedImage(bTypes[2], 8, 3, 10, 10, 30, 30) 
            },{
                left: createCachedImage(bTypes[3], -2, 3, 10, 10, 30, 30),
                right: createCachedImage(bTypes[3], 8, 3, 10, 10, 30, 30) 
            },{
                left: createCachedImage(bTypes[4], -2, 3, 10, 10, 30, 30),
                right: createCachedImage(bTypes[4], 8, 3, 10, 10, 30, 30) 
            },{
                left: createCachedImage(bTypes[5], -2, 3, 10, 10, 30, 30),
                right: createCachedImage(bTypes[5], 8, 3, 10, 10, 30, 30) 
            }];
            upgradeSpawnTimer = 0;
            bulletWeight = 1;
            kickbackDistance = 2;
            gameTime = 0;
            lastFrameTime = Date.now();
            stops = false;
            damageDe = 2.5;
            bullets = [];
            enemies = [];
            barriers = [];
            lastFire = 0;
            gameOver = false;
            score = 0;
            enemiesSizeBase = 15;
            enemyHealthBase = 3;
            enemyHealthRate = 1.45;
            enemySpawnRate = 2000;
            fillSpeedBase = 0.7
            lastFire = Date.now();
            mouseX = canvas.width/2;  
            restartBtn.style.display = 'none';
            difficultyApplyed = false;
            noFireRate = 0;
            difficulty = 1;

            triggerAnimation(offAnimation2);
        }

        // 鼠标控制
        document.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            // ctx.fillStyle = '#fff';
            // ctx.fillText(`Test: ${((e.clientY))}`, 50, 240);

            if (!(mouseX >= 10 && mouseX <= (canvas.width - 10)* scale) || e.clientY - rect.top <= canvas.height* scale/4){
                if (e.clientY - rect.top <= canvas.height* scale/4){
                    mouseX = player.x* scale;
                }else{
                    if(mouseX < 10){
                        mouseX = 10;
                    }else if(mouseX > (canvas.width - 10)* scale){
                        mouseX = (canvas.width - 10)* scale;
                    }
                }
            }
        });

        // for 手机等触摸设备
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = e.touches[0].clientX - rect.left;
            if (!(mouseX >= 10 && mouseX <= (canvas.width - 10)* scale) || e.touches[0].clientY - rect.top <= canvas.height/4){
                if (e.clientY - rect.top <= canvas.height* scale/4){
                    mouseX = player.x* scale;
                }else{
                    if(mouseX < 10){
                        mouseX = 10;
                    }else if(mouseX > (canvas.width - 10)* scale){
                        mouseX = (canvas.width - 10)* scale;
                    }
                }
            }
        });

        // 子弹移动
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.y -= bullet.speed* (deltaTime / 8.335)* timeScale;
                return bullet.y > -100;
            });
        }

        // 子弹绘制
        function drawBullets() {
                // bullets.forEach(bullet => {
                //     ctx.fillStyle = bulletColor(bullet.type);
                //     ctx.beginPath();
                //     ctx.arc(bullet.x, bullet.y-3, player.bulletWidth, 0, Math.PI*2);
                //     ctx.fill();
                // })
                
                // if (bullet.type>=5) ctx.stroke();
                const leftBullets = bullets.filter(b => !b.side);
                const rightBullets = bullets.filter(b => b.side);
                
                // 单次绘制同类型子弹
                if (leftBullets.length) {
                    leftBullets.forEach(b => ctx.drawImage(bulletCache[b.type-1].left, b.x-21, b.y-5));
                }
                if (rightBullets.length) {
                    rightBullets.forEach(b => ctx.drawImage(bulletCache[b.type-1].right, b.x-8, b.y-5));
                }
                

        }

        function updateEnemies() {
            // 生成敌人
            if((gameTime%15<=10) && (Date.now() - enemySpawnTimer > enemySpawnRate/timeScale)) {
                spawnEnemies(enemyHealthBase,fillSpeedBase,enemiesSizeBase,0);
                // spawnEnemies(enemyHealthBase*6,fillSpeedBase*1.4,enemiesSizeBase*1.2,player.bulletType);
                if (Math.random()<0.1 && gameTime>40 && 1+Math.log(enemyHealthBase)/4-difficulty>0.05)  spawnEnemies(enemyHealthBase/1.5,fillSpeedBase*2.5,enemiesSizeBase/1.5,0);
                enemySpawnTimer = Date.now();
            }

            if (gameTime>=bulletTypeSpawnTimeBase(player.bulletType) && gameTime - upgradeSpawnTimer > 25){
                spawnEnemies(enemyHealthBase*6,fillSpeedBase*1.4,enemiesSizeBase*1.2,player.bulletType);
                upgradeSpawnTimer = gameTime;
            }

            // 更新敌人位置 + 受伤特效
            
            enemies = enemies.filter(enemy => {
                if (enemy.health>0){
                    enemy.y += enemy.speed* (deltaTime / 8.335)* (timeScale);
                    if (Math.abs(enemy.rotate)>0){
                        if (Math.abs(enemy.rotate)<0.001){
                            enemy.rotate=0;
                        }
                        enemy.rotate /= 1.5 ** (deltaTime / 16.667); 
                    }
                    // 扣血+失败条件
                    if(enemy.y + enemy.size >= player.y && enemy.type===0) {
                        if (enemy.boss == 1){
                            player.health-=3;
                        }else{
                            if (enemy.speed>fillSpeedBase*2){
                                player.health-=0.5
                            }else{
                                player.health--;
                            }  
                        }
                        if (player.health <= 0){
                            gameOver = true;
                        }
                        enemy.y = 99999;
                    }
                }
                return enemy.y < canvas.height;
            });
        }

        // 确保文字在正中间的一系列函数
        function fitTextToWidth(text, targetWidth, maxHeight, fontFamily) {
            let minSize = 1;
            let maxSize = maxHeight;
            let fontSize = (minSize + maxSize) / 2;
            let count = 0;

            // 二分字体大小，猜猜看不加count会发生什么(
            while (maxSize - minSize > 1 && count < 100) {
                count++;
                ctx.font = `${fontSize}px ${fontFamily}`;
                const textWidth = ctx.measureText(text).width;

                if (textWidth > targetWidth) {
                    maxSize = fontSize; 
                } else {
                    minSize = fontSize; 
                }

                fontSize = Math.floor((minSize + maxSize) / 2);
            }

            ctx.font = `${fontSize}px ${fontFamily}`;
        }

        function measureTextHeight(font) {
            ctx.font = font;
            const metrics = ctx.measureText('M'); 
            const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
            return textHeight;
        }

        function drawText(text, x, y, targetWidth, maxHeight, fontFamily, color) {
            fitTextToWidth(text, targetWidth, maxHeight, fontFamily);
            ctx.textAlign = 'center';
            ctx.fillStyle = color;
            ctx.fillText(text, x, y+measureTextHeight(text)/2);
        }

        // 敌人绘制
        // 优先保证高速敌人在最上面，其次保证靠前的敌人在最上面
        function drawEnemies() {
            const enemySpeeds = [0,fillSpeedBase/2.5, fillSpeedBase*1.2, 114514];
            for (let i = 0; i < 3; i++) {
                Array.from(enemies).reverse().forEach(enemy => {
                    if (enemy.speed < enemySpeeds[i+1] && enemy.speed > enemySpeeds[i]){
                        // 判断难度和+-
                        const difficulty = Math.min(MaxD,1+Math.floor(Math.log(enemy.maxHealth)/4));
                        const remain = 1+Math.log(enemy.maxHealth)/4-Math.min(MaxD,Math.floor(1+Math.log(enemy.maxHealth)/4));
                        let add = '';
                        if (remain<1/3){
                            add = '-';
                        }
                        if (remain>2/3){
                            add = '+';
                        }
                        // 绘制敌人主体
                        if (enemy.type===0){
                            // ctx.fillStyle = `hsl(${enemy.health * 20 /enemy.maxHealth * (3+Math.log(1+enemy.health))}, 70%, 50%)`;
                            ctx.beginPath();
                            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; 
                            ctx.shadowOffsetX = 0; 
                            ctx.shadowOffsetY = enemy.size**0.5; 
                            ctx.shadowBlur = 12; 
                            ctx.globalAlpha = enemy.alpha;
                            ctx.save();
                            // 做了半天才发现translate函数be like:
                            ctx.globalAlpha = 1;
                            ctx.translate(enemy.x, enemy.y);
                            ctx.rotate(enemy.rotate * Math.PI / 180); 
                            // 小鬼警报系统() 
                            if (i==2 && enemy.health>0 && enemy.y >canvas.height/2.6) ctx.filter = 'drop-shadow(0px 0px '+Math.min(5,(enemy.y-canvas.height/2.6)/5)+'px #f00)';      
                            ctx.drawImage(dx[difficulty], -enemy.size, -enemy.size, 2*enemy.size,2*enemy.size);
                            ctx.globalAlpha = enemy.alpha;
                            drawText('D'+difficulty+add, 0, 0, enemy.size*2/1.2, enemy.size*2, 'Jellee', '#FFF');
                            ctx.restore();
                            // ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                            // ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                            ctx.shadowBlur = 0;
                            ctx.filter = 'none';
                        }else{
                            ctx.beginPath();
                            ctx.filter = 'drop-shadow(0px 0px 5px '+bulletColor(enemy.type+1)+')';
                            // ctx.fillRect(enemy.x-enemy.size, enemy.y-enemy.size,enemy.size*2,enemy.size*2);
                            // 十分激烈的坐标转换
                            ctx.drawImage(bTypes[player.bulletType], enemy.x-enemy.size-enemy.size/8, enemy.y-enemy.size+enemy.size/8, 16/7*enemy.size,16/7*enemy.size);
                            ctx.filter = 'none';
                        }
                        
                        if (enemy.health>0){
                            // 绘制血条背景
                            ctx.fillStyle = 'rgba(0,0,0,0.5)';
                            if (enemy.boss<1){
                                ctx.fillRect(enemy.x - 20, enemy.y - 10 - enemy.size, 40, 5);
                            }else{
                                ctx.fillRect(enemy.x - 40, enemy.y - 10 - enemy.size, 80, 5);
                            }
                            
                            // 绘制当前血量
                            const healthWidth = (enemy.health / enemy.maxHealth) * 36;
                            ctx.fillStyle = enemy.health > enemy.maxHealth*0.4 ? '#0f0' : '#f00';
                            ctx.fillStyle = `hsl(${enemy.health / enemy.maxHealth * 120}, 70%, 50%)`;

                            if (enemy.boss<1){
                                ctx.fillRect(enemy.x - 18, enemy.y - 8 - enemy.size, healthWidth, 2);
                            }else{
                                ctx.fillRect(enemy.x - 38, enemy.y - 8 - enemy.size, healthWidth*2, 2);
                            }

                            // 显示血量数值
                            // document.fonts.ready.then(function() {
                            ctx.font = "15px 'Jellee'";
                            ctx.textAlign = 'center';
                            ctx.lineWidth = 3;
                            
                            ctx.strokeStyle = '#000';
                            ctx.strokeText(enemy.health.toFixed(1), enemy.x, enemy.y - 15 - enemy.size);
                            ctx.strokeStyle = 'rgba(255,255,255,0)';

                            ctx.fillStyle = '#FFF';
                            ctx.fillText(enemy.health.toFixed(1), enemy.x, enemy.y - 15 - enemy.size);
                            //});
                        }
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
        }

        function spawnEnemies(health,speed,size,type) {
            const maxAttempts = 100; // 有效位最大尝试次数
            let newEnemy = null;
            let isValidPosition = false;
            
            // 生成有效位置
            for(let i=0; i<maxAttempts; i++){
                newEnemy = {
                    x: Math.random() * (canvas.width - 30 - size * 2) + 15 + size,
                    y: -100,
                    health: health,
                    size: size, 
                    speed: speed,
                    maxHealth: health,
                    boss: 0,
                    type: type,
                    rotate: 0,
                    alpha: 0.99999,
                    ySpeed: 0,
                    xSpeed: 0,
                    yAddSpeed: 0
                };

                // 碰撞检测
                if(!checkEnemyCollision(newEnemy)){
                    isValidPosition = true;
                    break;
                }
            }

            if(!isValidPosition){
                console.log('哥们没位了,给你随便找个地方生了(?)');
            }
            enemies.push(newEnemy);
        }

        // 加成屏障绘制
        function drawBarriers() {
            barriers.forEach(barrier => {
                // 绘制左侧区域
                ctx.fillStyle = barrier.leftValue >= 0 ? 'rgba(0,255,0,50%)' : 'rgba(255,0,0,50%)';
                ctx.fillRect(0, barrier.y, canvas.width/2, 20);
                
                // 绘制右侧区域
                ctx.fillStyle = barrier.rightValue >= 0 ? 'rgba(0,255,0,50%)' : 'rgba(255,0,0,50%)';
                ctx.fillRect(canvas.width/2, barrier.y, canvas.width/2, 20);

                // 绘制隔断
                ctx.fillStyle = '#000';
                ctx.fillRect(canvas.width/2-2, barrier.y, 4, 20);
                
                // 显示数值
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                if (barrier.leftValue > 0){
                    ctx.fillText(
                        `${barrier.typel}: +${barrier.leftValue.toFixed(1)}`, 
                        canvas.width/4, barrier.y + 15
                    );
                }else{
                    ctx.fillText(
                        `${barrier.typel}: ${barrier.leftValue.toFixed(1)}`, 
                        canvas.width/4, barrier.y + 15
                    );
                }

                if (barrier.rightValue > 0){
                    ctx.fillText(
                        `${barrier.typer}: +${barrier.rightValue.toFixed(1)}`, 
                        canvas.width*3/4 + 10, barrier.y + 15
                    );
                }else{
                    ctx.fillText(
                        `${barrier.typer}: ${barrier.rightValue.toFixed(1)}`, 
                        canvas.width*3/4 + 10, barrier.y + 15
                    );
                }
            });
        }

        // 碰撞检测
        function checkCollisions() {
            const bulletsToRemove = new Set();
            const enemiesToRemove = new Set();

            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    // const xDistance = Math.abs(bullet.x - enemy.x);
                    let l=0;
                    let r=0;
                    
                    if (bullet.side){
                        l=bullet.width*2;
                    }else{
                        r=bullet.width*2;
                    }

                    // 令人忍俊不禁的碰撞检测，主要是为了子弹穿透效果包的饺子(
                    if( bullet.y>-2 &&
                        enemy.health>0 &&
                        bullet.x - enemy.x < enemy.size + bullet.width +r &&
                        enemy.x - bullet.x < enemy.size + bullet.width +l &&
                        bullet.y <= enemy.y + enemy.size + bullet.width &&
                        bullet.y > enemy.y + enemy.size + bullet.width - bullet.speed* (deltaTime / 8.335)*timeScale - enemy.speed* (deltaTime / 8.335)*timeScale
                    ){
                        if (gameTime > bulletTypeSpawnTimeBase(player.bulletType)){
                            enemy.health -= (bullet.damage * player.damage)*1.145**((gameTime-bulletTypeSpawnTimeBase(player.bulletType))/10);
                        }else{
                          enemy.health -= bullet.damage * player.damage;
                        }
                        
                        //没错，受伤抖动幅度甚至和敌人剩余血量有关
                        if (Math.abs(enemy.rotate)<0.5){
                            const rotateA = Math.min(30,5+40/(enemy.size) * (Math.random()+(enemy.maxHealth/enemy.health)**1.5));
                            enemy.rotate = Math.random()>0.5?rotateA:-rotateA;
                        }
                        
                        if (enemy.type===0){
                            if (enemy.boss===1){
                                enemy.y=Math.max(-100,enemy.y-kickbackDistance/(Math.min(16,player.bulletCount)**0.5));
                            }else{
                                enemy.y=Math.max(-100,enemy.y-kickbackDistance);
                            }
                        }else{
                            enemy.y=Math.max(-100,enemy.y-kickbackDistance/2);                          
                        }
                        
                        bullet.c-=1;
                        bullet.y-=bullet.speed* (deltaTime / 8.335) * timeScale;
                        if (bullet.c<1){
                            bulletsToRemove.add(bIndex);
                        }
                    }
                });
            });
            enemies.forEach((enemy, eIndex) => {
                if (enemy.health < 0.05) {
                    enemy.health=0;
                    enemy.alpha = Math.max(0.01,(enemy.alpha-0.03));
                    //没错，敌人死亡后的抛物线甚至和子弹速度有关
                    if (enemy.yAddSpeed == 0){
                        enemy.ySpeed = -(player.bulletSpeed**0.5*(Math.random()/3+1.1))-7;
                        enemy.yAddSpeed = 0.98/1.5;    //地心引力.jpg
                        enemy.xSpeed = (enemy.x<canvas.width/2?-1:1)*((Math.random()+0.5)*(player.bulletSpeed**0.5)+1);
                        enemy.rotate = 0;
                    }else{
                        enemy.x+=enemy.xSpeed* (deltaTime / 16.667);
                        enemy.y+=enemy.ySpeed* (deltaTime / 16.667);
                        enemy.ySpeed+=enemy.yAddSpeed* (deltaTime / 16.667);
                        enemy.rotate+=enemy.xSpeed* (deltaTime / 16.667)*2;
                    }
                }
                if (enemy.health == 0 && (enemy.alpha <= 0.001 || enemy.type >= 1)) {
                    enemiesToRemove.add(eIndex);
                    if (enemy.boss == 1){
                        score += 30;
                    }else{
                        score += 10;
                    }
                    if (enemy.type>=1){
                        player.bulletType = enemy.type+1;
                        player.bulletCount = 4;
                        player.fireRate *= 30;
                        player.bulletSpeed = bulletSpeed(player.bulletType);
                        player.fireLim = fireLims[player.bulletType-1];
                        player.maxHealth++;
                        player.ar=3;
                        player.at=1;
                    }
                }
            });

            Array.from(bulletsToRemove).reverse().forEach(i => bullets.splice(i, 1));
            Array.from(enemiesToRemove).reverse().forEach(i => enemies.splice(i, 1));
        }

        // 游戏界面
        function drawUI() {
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.font = '20px Jellee';
            // ctx.fillText(`伤害: ${player.damage.toFixed(1)}`, 10, 120);
            // ctx.fillText(`攻速: ${(1000/player.fireRate).toFixed(1)}`, 10, 90);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 5;
            ctx.strokeText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.strokeText(`Time: ${(gameTime)}`, 10, 60);
            ctx.fillText(`Time: ${(gameTime)}`, 10, 60);
            ctx.strokeStyle = 'rgba(255,255,255,0)';
            //  ctx.fillText(`De: ${(damageDe.toFixed(2))}`, 10, 150);
            //  ctx.fillText(`BW: ${(bulletWeight.toFixed(2))}`, 10, 180);
            //  ctx.fillText(`EHR: ${(enemyHealthRate.toFixed(2))}`, 10, 210);
            //  ctx.fillText(`ESR: ${(enemySpawnRate.toFixed(2))}`, 10, 240);
            //  ctx.fillText(`NF: ${(noFireRate.toFixed(2))}`, 10, 270);
            //  ctx.fillText(`FLim: ${(player.fireLim.toFixed(2))}`, 10, 300);
            //  ctx.fillText(`KB: ${(kickbackDistance.toFixed(4))}`, 10, 330);
            //  ctx.fillText(`at: ${(player.at.toFixed(4))}`, 10, 360);
            //  ctx.fillText(`ar: ${(player.ar.toFixed(4))}`, 10, 390);
            //  ctx.fillText(`d: ${(difficulty)}`, 10, 420);
            //  ctx.fillText(`dt: ${(deltaTime)}`, 10, 450);
            ctx.textAlign = 'center';

            ctx.stroke();
            if(gameOver) {
                ctx.fillStyle = '#f00';
                ctx.font = 'bold 40px Arial';
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#000';
                ctx.strokeText('游戏结束!', canvas.width/2, canvas.height/2);
                ctx.fillText('游戏结束!', canvas.width/2, canvas.height/2);
                
                restartBtn.style.display = 'block';
            }
        }

        // 暂停
        function stop() {
            if (gameOver) return;
            stops = !stops;
            if (stops) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px Arial';
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#000';
                ctx.strokeText('暂停', canvas.width/2, canvas.height/2);
                ctx.fillText('暂停', canvas.width/2, canvas.height/2);
                stopTime = Date.now();
                clearInterval(interval);
                clearInterval(interval2);
                background.classList.add('animate')
            }else{
                // 这里说实话貌似有点小bug，但不好修，也不知道是什么，反正看到再说吧()
                enemySpawnTimer += (Date.now()-stopTime);
                lastFrameTime = Date.now();
                lastFire += (Date.now()-stopTime);
                lastSec += (Date.now()-stopTime)/1000/timeScale;
                gameLoop();
                
            }
    
        }

        // 别问我为什么这点东西都要单独开2个函数()
        function moveLeft() {
            player.x = Math.max(10, player.x - player.speed);
        }
        function moveRight() {
            player.x = Math.min(canvas.width-10, player.x + player.speed);
        }

        // 游戏主循环
        function gameLoop() {
            if(gameOver) return;
            if(stops) return;
            const currentTime = Date.now();
            if (lastSec < currentTime/1000){
                lastSec = 1/timeScale+currentTime/1000;
                gameTime++;

                bossSpawn();
                if (player.bulletType==1){
                    if (gameTime<=20){
                        player.fireRate/=1.04;
                        player.bulletSpeed = Math.min(5,player.bulletSpeed*1.05);
                    }
                }
            }

            if (player.at>0.0001){
                player.at/=1.05**(deltaTime / 16.667);
                player.ar*=1.2**(deltaTime / 16.667);
            }
            
            deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // if(keys.ArrowLeft) player.x = Math.max(10, player.x - player.speed);
            // if(keys.ArrowRight) player.x = Math.min(canvas.width-10, player.x + player.speed);
            // 更新玩家位置
            player.x = mouseX / scale;

            // 生成子弹
            if(Date.now() - lastFire > player.fireRate / timeScale) {
                const fires = Math.floor((Date.now() - lastFire)/player.fireRate);
                const spreadStep = player.bulletSpread;
                const startOffset = -(player.bulletCount-1)*spreadStep/2;
                const bulletDamage = bulletDamageCalc(player.bulletType);
                const bulletX = bulletXCalcs(player.bulletType);
                // 攻速多到60fps加不完? 没事，我们有最陷阱的自动子弹补间（
                for (let j=0; j<fires; j++){
                    for(let i=0; i<player.bulletCount; i++){
                        bullets.push({
                            c: bulletX,
                            x: player.x + startOffset + i*spreadStep,
                            y: player.y + j * ((player.bulletSpeed* (deltaTime / 8.335))*timeScale/fires),
                            type: player.bulletType,
                            width: player.bulletWidth,
                            speed: player.bulletSpeed,
                            damage: bulletDamage,
                            side: i+1>player.bulletCount/2+0.5
                        });
                    }
                }
                lastFire += fires * player.fireRate / timeScale;
            }
            
            // 更新游戏对象
            increaseDifficulty();
            updateBullets();
            updateEnemies();
            updateBarriers();
            checkCollisions();
            
            // 绘制所有元素
            drawBullets();
            drawPlayer();
            drawEnemies();
            drawBarriers();
            drawUI();
            let frameRate = 1000 / deltaTime;
            ctx.textAlign = 'right';
            ctx.fillStyle = '#888';
            ctx.fillText(`FPS: ${frameRate.toFixed(1)}`, canvas.width-10, 30);
            ctx.textAlign = 'center';
            requestAnimationFrame(gameLoop);

            
       }

        // 玩家绘制
        function drawPlayer() {
            ctx.fillStyle = colorWithOpacity(colors[player.bulletType-1],player.at)
            ctx.arc(player.x, player.y, player.ar, 0, Math.PI * 2);
            ctx.fill();
            //玩家血条
            ctx.fillStyle = '#000';
            ctx.fillRect(0, canvas.height-30, canvas.width, 30);

            ctx.fillStyle = `hsl(${player.health * 20 /player.maxHealth * (3+Math.log(1+player.health))}, 70%, 45%)`;
            ctx.fillRect(5, canvas.height-25, canvas.width*player.health/player.maxHealth-10, 19);

            ctx.fillStyle = '#fff';
            ctx.font = '15px Jellee';
            ctx.fillText(` ${player.health.toFixed(1)} / ${player.maxHealth.toFixed(1)}`, canvas.width/2,canvas.height-11);

            ctx.fillStyle = '#00f';
            ctx.fillRect(player.x-10, player.y, 20, 10);
        }

        // 神必的颜色和透明度合成
        function colorWithOpacity(color, opacity) {
            if (color.startsWith('#')) {
                color = hexToRgb(color);
            }
            if (color.startsWith('rgb')) {
                return color.replace(')', `, ${opacity})`).replace('rgb', 'rgba');
            }
            return color; 
        }

        // 十六进制转RGB
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');

            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);

            return `rgb(${r},${g},${b})`;
        }

        // 事件监听
        // const keys = { ArrowLeft: false, ArrowRight: false };
        // window.addEventListener('keydown', e => keys[e.key] = true);
        // window.addEventListener('keyup', e => keys[e.key] = false);
        window.addEventListener('keydown', e => {
            if (e.key=='s'){
                stop();
            }
        });
        restartBtn.addEventListener('click', () => {
            initGame();
            gameLoop();
        });
        
        bType6.onload = function() {
            // 启动游戏
            initGame();
            gameLoop();
        };
        
        

        function createCachedImage(source, sx, sy, sw, sh, dw, dh) {
            const cacheCanvas = new OffscreenCanvas(dw, dh);
            const cacheCtx = cacheCanvas.getContext('2d');
            cacheCtx.drawImage(source, sx, sy, sw, sh, 0, 0, dw, dh);
            return cacheCanvas;
        }
        
        

        // 鼠标和触摸事件的处理函数
        function startIncrement() {
            if (stops) return;
            interval = setInterval(() => {
                moveRight();
            }, 10);
        }

        function stopIncrement() {
            clearInterval(interval);
        }

        function startIncrement2() {
            if (stops) return;
            interval2 = setInterval(() => {
                moveLeft();
            }, 10);
        }

        function stopIncrement2() {
            clearInterval(interval2);
        }

        buttonR.addEventListener('mousedown', startIncrement);
        buttonR.addEventListener('mouseup', stopIncrement);
        buttonR.addEventListener('mouseleave', stopIncrement); 
        buttonL.addEventListener('mousedown', startIncrement2);
        buttonL.addEventListener('mouseup', stopIncrement2);
        buttonL.addEventListener('mouseleave', stopIncrement2);
        buttonR.addEventListener('touchstart', (event) => {
            event.preventDefault(); 
            startIncrement();
        });
        buttonR.addEventListener('touchend', stopIncrement);
        buttonL.addEventListener('touchstart', (event) => {
            event.preventDefault(); 
            startIncrement2();
        });
        buttonL.addEventListener('touchend', stopIncrement2);

        function generateBulletPaths(currentCount) {
            const MAX_BULLETS = Maxbullets[player.bulletType-1];
            const weights = [];    // 概率权重数组
            
            // 根据当前数量生成权重（越接近上限概率越低）
            for(let i=1; i<=5; i++){ // 最多弹道+5
                const possible = currentCount + i;
                if(possible > MAX_BULLETS) continue;
                weights.push({
                    value: i,
                    weight: 1/(i**3) // 权重衰减，越多的弹道越难生成，所以出现弹道+5的概率至少是1/125
                });
            }
            
            // 随机选择
            if(weights.length === 0) return 1;
            const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
            let random = Math.random() * totalWeight;
            
            for(const w of weights){
                if(random < w.weight) return w.value;
                random -= w.weight;
            }
            return 1;
        }

        function updateBarriers() {
            // 每5秒生成屏障 (加成)
            if(gameTime%5 ===0 && barrierCD === false) {
                let firstV = generateBulletPaths(player.bulletCount);
                let secV = generateBulletPaths(player.bulletCount);
                let ltypes = '弹道';
                let rtypes = '弹道';

                // 十分激烈的概率计算
                bulletWeight = 1.5*(0.5+(20*player.bulletCount/Maxbullets[player.bulletType-1])**(0.7)/4);
                if (gameTime>bulletTypeSpawnTimeBase(player.bulletType)-100 && player.bulletCount < Maxbullets[player.bulletType-1]/2) bulletWeight /=3;
                if (gameTime>20 && gameTime<400 && player.bulletCount < 2) bulletWeight /=3;
                if((noFireRate>=5 && player.fireRate > player.fireLim) || Math.random()*bulletWeight > 0.1 || player.bulletCount>=Maxbullets[player.bulletType-1]){
                    firstV = 2*(Math.random()*5 - 3);
                    ltypes = '攻速';
                    if ((noFireRate<5 && Math.random()>0.35) || player.fireRate <= player.fireLim){
                        ltypes = '伤害';
                        firstV *= enemyHealthBase/5/damageDe;
                        firstV += firstV>=0?0.5:-0.5;
                    }else{
                        firstV += firstV>=0?0.3:-0.3;
                    }
                }
                if((noFireRate>=5 && player.fireRate > 5) || Math.random()*bulletWeight > 0.1 || player.bulletCount>=Maxbullets[player.bulletType-1]){
                    secV = 2*(Math.random()*5 - 3);
                    rtypes = '攻速';
                    if ((noFireRate<5 && Math.random()>0.35) || player.fireRate <= player.fireLim){
                        rtypes = '伤害';
                        secV *= enemyHealthBase/5/damageDe;
                        secV += secV>=0?0.5:-0.5;
                    }else{
                        secV += secV>=0?0.3:-0.3;
                    }
                }

                if(Math.random()>0.5){
                    if (firstV<0 && secV<0) firstV = -firstV;
                }else{
                    if (firstV<0 && secV<0) secV = -secV;
                }

                if ((firstV<=0 || ltypes !== '攻速') && (secV<=0 || rtypes !== '攻速')){
                    noFireRate++;
                }else{
                    noFireRate = 0;
                }


                barriers.push({
                    y: 0,
                    leftValue: firstV,  
                    rightValue: secV,
                    typel: ltypes,
                    typer: rtypes
                });


                
                barrierCD = true;
            }else if(gameTime%5 !=0 ){
                barrierCD = false;
            }

            // 记录到底的屏障以供移除
            const barriersToRemove = [];
            barriers.forEach(barrier => {
                barrier.y += fallSpeedBase* (deltaTime / 8.335) * timeScale;
                if(barrier.y + 20 >= player.y) {
                    applyUpgrade(barrier);
                    barriersToRemove.push(barrier);
                }
            });
            barriers = barriers.filter(b => !barriersToRemove.includes(b));
        }

        // 屏障碰到玩家所应用的加成
        function applyUpgrade(barrier) {
            const area = player.x < canvas.width/2 ? 'leftValue' : 'rightValue';
            const types = barrier[(player.x < canvas.width/2 ? 'typel' : 'typer')];
            const value = barrier[area];
            
            switch(types) {
                case '攻速':
                    if (player.fireRate >= player.fireLim ){
                        player.fireRate = Math.max(player.fireLim, player.fireRate - (0.5+value*player.fireRate/15));
                        // if (player.fireRate - value*50 < 100){
                        //     player.fireRate = Math.max(1, player.fireRate - Math.floor(value*player.fireRate/10));
                        // }else{
                        //     player.fireRate = Math.max(1, player.fireRate - value*50);
                        // }
                    }else{
                        player.damage += value*enemyHealthBase/5/damageDe;
                    }
                    break;
                case '伤害':
                    player.damage += value;
                    break;
                case '弹道':
                    player.bulletCount = Math.min(
                        Maxbullets[player.bulletType-1], 
                        Math.max(1, player.bulletCount + value)
                    );
                    break;
            }
        }

        function checkEnemyCollision(newEnemy) {
            // 边界检测（左右各留1.5倍半径空间）
            const safeMargin = newEnemy.size * 1.5;
            if(newEnemy.x < safeMargin || 
            newEnemy.x > canvas.width - safeMargin) {
                return true;
            }

            // 与现有敌人的碰撞检测
            return enemies.some(existingEnemy => {
                const dx = Math.abs(newEnemy.x - existingEnemy.x);
                const dy = Math.abs(newEnemy.y - existingEnemy.y);
                const dsize = (newEnemy.size + existingEnemy.size);
                return dx<dsize && dy<dsize;
                //return distance < (newEnemy.size + existingEnemy.size);
            });
        }
        
        
        function increaseDifficulty() {
            if(gameTime%10 === 0 && !difficultyApplyed) {
                
                difficultyApplyed = true;
                if (gameTime>=2200){
                    damageDe *= 1.02;
                }else{
                    damageDe = Math.max(1.17,enemyHealthRate/1.15)*damageDe;
                }
                enemyHealthRate = Math.max(1.2,enemyHealthRate/1.008);
                enemyHealthBase *= enemyHealthRate;
                enemySpawnRate = Math.max(50, enemySpawnRate*1/(0.945+1/((gameTime**0.22*2.5))));
                enemiesSizeBase = Math.min(35,enemiesSizeBase*1.05);
                fillSpeedBase = Math.min(2.5,fillSpeedBase+0.02);
                kickbackDistance = Math.max(0.06/1.25**(player.bulletType-1),kickbackDistance*0.9);
                const nowD = Math.min(MaxD,1+Math.floor(Math.log(enemyHealthBase)/4));

                if (difficulty !== nowD){
                    difficulty = nowD;
                    updateBG();
                }
            }else if(gameTime%10 != 0){
                difficultyApplyed = false;
            }
        }

        function bossSpawn() {
            if (gameTime%20 === 0){
                const maxAttempts = 100; // 最大尝试次数
                let newEnemy = null;
                let isValidPosition = false;

                //玩家回血
                player.health = Math.min(player.maxHealth,player.health+player.maxHealth/25);
                
                // 照搬spawnEnemy就完事了
                for(let i=0; i<maxAttempts; i++){
                    newEnemy = {
                        x: Math.random() * (canvas.width - 30 - enemiesSizeBase*6) + 15 + enemiesSizeBase*3,
                        y: -105,
                        health: enemyHealthBase*10*Math.log(gameTime**(1/2)),
                        size: enemiesSizeBase*3, 
                        speed: fillSpeedBase/3.5,
                        maxHealth: enemyHealthBase*10*Math.log(gameTime**(1/2)),
                        boss: 1,
                        type: 0,
                        rotate: 0,
                        alpha: 0.99999,
                        ySpeed: 0,
                        xSpeed: 0,
                        yAddSpeed: 0
                    };

                    if(!checkEnemyCollision(newEnemy)){
                        isValidPosition = true;
                        break;
                    }
                }
                enemies.push(newEnemy);
            }
        }

        // 别问为什么... 当我搓完一堆switch后灵光一闪就成这样了(
        function bulletDamageCalc(type){
            if (type>=1 && type<=6) return damageTypes[type-1];
        }

        function bulletXCalcs(type){
            if (type>=1 && type<=6) return XTypes[type-1];
        }
        
        function bulletTypeSpawnTimeBase(type){
            if (type>=1 && type<=6) return upgradeSpawnTime[type-1];
        }

        function bulletColor(type){
            if (type>=1 && type<=6) return colors[type-1];
        }

        function bulletSpeed(type){
            if (type>=1 && type<=6) return bulletSpeeds[type-1];
        }

        // 背景动画合集
        function triggerAnimation(callback) {
            const bg = document.querySelector('.bg-container');
            if (callback) {
                addEndListener(bg, callback);
            }
            bg.classList.add('active');
        }

        function triggerAnimation2(callback) {
            const bg = document.querySelector('.bg2-container');
            if (callback) {
                addEndListener(bg, callback);
            }
            bg.classList.add('active');
        }

        function offAnimation() {
            const bg = document.querySelector('.bg-container');
            bg.classList.remove('active');
        }
        
        function offAnimation2() {
            const bg = document.querySelector('.bg2-container');
            bg.classList.remove('active');
        }

        // 背景动画结束后，再把上一层背景扬了(
        function addEndListener(element, callback) {
            element.addEventListener('transitionend', function handler(event) {
                // 背景好像不需要这个if，但谁知道我以后会加些什么玩意(
                if (event.target === element) {
                    element.removeEventListener('transitionend', handler); 
                    callback();
                }
            });
        }
    </script>
</body>
</html>
